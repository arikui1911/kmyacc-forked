%{
%}

%token ADD SUB MUL DIV CR NUMBER_LITERAL

%%

program :
        | line_list
        ;

line_list : line
          | line_list line
          ;

line : CR
     | expr CR
     {
         puts(">>> %f" % $1)
     }
     ;

expr : term
     | expr ADD term
     {
         $$ = $1 + $3
     }
     | expr SUB term
     {
         $$ = $1 - $3
     }
     ;

term : primary
     | term MUL primary
     {
         $$ = $1 * $3
     }
     | term DIV primary
     {
         $$ = $1 / $3
     }
     ;

primary : NUMBER_LITERAL
        ;

%%

#"

module Calc
  class Lexer
    include ParserObservable

    def initialize(src)
      @src = src
      @iter = lex()
    end

    def yylex
      @iter.next
    end

    private

    OP = {
      '+' => Tokens.ADD,
      '-' => Tokens.SUB,
      '*' => Tokens.MUL,
      '/' => Tokens.DIV,
    }

    def lex
      return enum_for(__method__) unless block_given?
      @src.each_line do |line|
        rest = line
        until rest.empty?
          case rest
          when /\A[\r\n\s]+/
            ;
          when /\A\d+\.\d+/, /\A\d+/
            yylval_set Float($&)
            yield Tokens.NUMBER_LITERAL
          when /\A[\+\-\*\/]/
            yield OP.fetch($&)
          when /\A./
            raise "invalid character - `#{$&}'"
          else
            raise Exception, 'must not happen'
          end
          rest = $'
        end
        yield Tokens.CR
      end
      while true
        yield 0
      end
    end
  end
end


lexer = Calc::Lexer.new($stdin)
parser = Calc::Parser.new(lexer, debug: true)
parser.yyparse
